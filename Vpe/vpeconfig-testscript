package main // Assuming your function is in the main package

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"testing"

	// You'll need to import the necessary libraries used in your function
	// For testing purposes, we'll need yaml and possibly others.
	// Assuming you are using gopkg.in/yaml.v2
	"gopkg.in/yaml.v2"
	// Assuming fnt is a custom error formatting package, replace with fmt if not
	// "your_fnt_package"
	// For this test, I'll use fmt.Errorf
	// "log" // log.Fatalf is used in the function, but we won't use it in tests directly
)

// Define the structs based on the YAML structure implied by the function
type VPEConfig struct {
	RequestInputXML RequestInputXML `yaml:"RequestInputXML"`
}

type RequestInputXML struct {
	ApplnName          string        `yaml:"ApplnName"`
	MicroserviceName   string        `yaml:"MicroserviceName"`
	TestType           string        `yaml:"TestType"`
	DL                 string        `yaml:"DL"` // Assuming DL maps to D1 in Setenv
	ApiErrors          *float64      `yaml:"ApiErrors"`
	ResponseTime       *float64      `yaml:"ResponseTime"`
	Duration           *int          `yaml:"Duration"`
	VUsers             *int          `yaml:"VUsers"`
	SSLRequired        bool          `yaml:"SSLRequired"`
	ThreadGroup        ThreadGroup   `yaml:"ThreadGroup"`
}

type ThreadGroup struct {
	ThreadLoadPercentage int             `yaml:"ThreadLoadPercentage"`
	SessionEndpoint      []SessionEndpoint `yaml:"SessionEndpoint"`
	Endpoint             []Endpoint      `yaml:"Endpoint"`
}

type SessionEndpoint struct {
	Title        string     `yaml:"Title"`
	HeadersFile  string     `yaml:"HeadersFile"`
	BodyJSONs    BodyJSONs  `yaml:"BodyJSONs"`
	APIName      string     `yaml:"APIName"`
	Method       string     `yaml:"Method"`
	ResponseString string   `yaml:"ResponseString"`
	Extracter    string     `yaml:"Extracter"`
}

type Endpoint struct {
	Title        string     `yaml:"Title"`
	HeadersFile  string     `yaml:"HeadersFile"`
	BodyJSONs    BodyJSONs  `yaml:"BodyJSONs"`
	APIName      string     `yaml:"APIName"`
	Method       string     `yaml:"Method"`
	ResponseString string   `yaml:"ResponseString"`
	Extracter    string     `yaml:"Extracter"`
	Domain       string     `yaml:"Domain"`
	LoopCount    int        `yaml:"LoopCount"`
	ExecuteOnce  bool       `yaml:"ExecuteOnce"`
}

type HeadersConfig struct {
	Headers Headers `yaml:"Headers"`
}

type Headers struct {
	Header []Header `yaml:"Header"`
}

type Header struct {
	Name  string `yaml:"Name"`
	Value string `yaml:"Value"`
}

type BodyJSONs struct {
	BodyJSON []BodyJSON `yaml:"BodyJSON"`
}

type BodyJSON struct {
	Name  string `yaml:"Name"`
	Value string `yaml:"Value"`
}

type ExtracterConfig struct {
	Extracter Extracter `yaml:"Extracter"`
}

type Extracter struct {
	RegexExtract []RegexExtract `yaml:"RegexExtract"`
}

type RegexExtract struct {
	Name  string `yaml:"Name"`
	Type  string `yaml:"Type"`
	Value string `yaml:"Value"`
}

// Dummy function for removeNextClosingBrace - replace with actual implementation if available
func removeNextClosingBrace(s string) string {
	// Placeholder implementation - assuming it does some string manipulation
	// For testing, we'll just return the input string
	return s
}

// Dummy function for loadEnvVars - replace with actual implementation if available
func loadEnvVars(filePath string) error {
	// Placeholder implementation - assuming it loads env vars from a file
	// For testing, we'll just return nil
	return nil
}

// Assuming fnt.Errorf is fmt.Errorf for this test
var fnt = fmt{}

type fmt struct{}

func (fmt) Errorf(format string, a ...interface{}) error {
	return fmt.Errorf(format, a...)
}

// --- Your function goes here ---
// func validateVpeconfigAndFiles(vpeconfigFolderPath string) error { ... }
// Make sure your function is accessible for testing (e.g., not in a different package without export)
// For this example, I'll assume it's in the same package and named as provided.

// Paste your function code here for the test file
func validateVpeconfigAndFiles(vpeconfigFolderPath string) error {
	configFilePath := filepath.Join(vpeconfigFolderPath, "Config.yml")
	data, err := os.ReadFile(configFilePath)
	if err != nil {
		return fnt.Errorf("failed to read VPEConfig.yml: %w", err)
	}
	fmt.Printf("Successfully read VPEConfig.yml:\n") // Added newline for clarity

	var config VPEConfig
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		// Original code uses log.Fatalf, which exits.
		// For testability, this should ideally return an error.
		// We'll keep it as is for now to match the user's function,
		// but note that tests hitting this will cause the test to exit.
		// log.Fatalf("error: %w", err)
		// Returning an error for better testability:
		return fmt.Errorf("failed to unmarshal VPEConfig.yml: %w", err)
	}

	// Capture environment variables set by the function for testing
	originalApplnName := os.Getenv("ApplnName")
	originalMicroserviceName := os.Getenv("MicroserviceName")
	originalTestTypeEnv := os.Getenv("TestType")
	originalD1 := os.Getenv("D1")
	defer os.Setenv("ApplnName", originalApplnName)
	defer os.Setenv("MicroserviceName", originalMicroserviceName)
	defer os.Setenv("TestType", originalTestTypeEnv)
	defer os.Setenv("D1", originalD1)

	os.Setenv("ApplnName", config.RequestInputXML.ApplnName)
	os.Setenv("MicroserviceName", config.RequestInputXML.MicroserviceName)
	os.Setenv("TestType", config.RequestInputXML.TestType)
	os.Setenv("D1", config.RequestInputXML.DL) // Corrected from DL to D1 based on Setenv

	envVarsFilePath := filepath.Join(vpeconfigFolderPath, "env_vars") // Use folder path for env_vars
	file, err := os.Create(envVarsFilePath)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return nil // Original code returns nil on error here, which is unusual
	}
	defer file.Close()

	envVars := []string{
		fmt.Sprintf("export ApplnName=\"%s\"\n", config.RequestInputXML.ApplnName),
		fmt.Sprintf("export MicroserviceName=\"%s\"\n", config.RequestInputXML.MicroserviceName),
		fmt.Sprintf("export TestType=\"%s\"\n", config.RequestInputXML.TestType), // Corrected format string
		fmt.Sprintf("export Dl=\"%s\"\n", config.RequestInputXML.DL),             // Corrected format string and variable name
	}

	for _, envVar := range envVars {
		if _, err := file.WriteString(envVar); err != nil { // Added _ for unused return value
			fmt.Println("Error writing to file:", err)
			return nil // Original code returns nil on error here
		}
	}

	fmt.Println("Environment variables written to env_vars")

	// Corrected VUsers modification logic
	if config.RequestInputXML.VUsers != nil && config.RequestInputXML.ThreadGroup.ThreadLoadPercentage != 100 {
		vusers := (float64(*config.RequestInputXML.VUsers) * float64(config.RequestInputXML.ThreadGroup.ThreadLoadPercentage)) / 100
		*config.RequestInputXML.VUsers = int(vusers)
	}

	var testType string // This variable is declared but not assigned before the next line
	// Corrected assignment and check
	testType = config.RequestInputXML.TestType
	fmt.Printf("Test Type: %s\n", testType) // Corrected to use the assigned testType variable

	testTypeList := strings.Split(testType, ",")

	for _, testType := range testTypeList {
		testType = strings.TrimSpace(testType)

		var jsCode strings.Builder
		jsCode.WriteString("import http from 'k6/http';\n")
		jsCode.WriteString("import { check, sleep } from 'k6';\n") // Corrected import syntax

		if testType != "" {
			jsCode.WriteString(fmt.Sprintf("//testType=%s\n", testType)) // Corrected format specifier
		}
		if config.RequestInputXML.ApiErrors != nil {
			jsCode.WriteString(fmt.Sprintf("//apiError=%.2f\n", *config.RequestInputXML.ApiErrors)) // Corrected format specifier
		}
		if config.RequestInputXML.ResponseTime != nil {
			jsCode.WriteString(fmt.Sprintf("//responseTime=%.2f\n", *config.RequestInputXML.ResponseTime)) // Corrected format specifier
		}
		if config.RequestInputXML.Duration != nil {
			jsCode.WriteString(fmt.Sprintf("//duration=%d\n", *config.RequestInputXML.Duration)) // Corrected format specifier
		}
		if config.RequestInputXML.VUsers != nil {
			jsCode.WriteString(fmt.Sprintf("//vusers=%d\n\n", *config.RequestInputXML.VUsers))
		}

		// Corrected conditional logic and string formatting
		if testType == "soak" {
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTlsVerify: true,\n};\n") // Added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {};\n") // Added closing brace and semicolon
			}
		} else if testType == "sanity" { // Corrected comparison operator
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTlsVerify: true,\n};\n") // Added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {};\n") // Added closing brace and semicolon
			}
		} else if testType == "functional" { // Corrected comparison operator
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTlsVerify: true,\n};\n") // Added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {};\n") // Added closing brace and semicolon
			}
		} else if testType == "breakpoint" {
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTLSVerify: true,\n};\n") // Corrected typo, added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {\n executor: 'ramping-vus',\n};\n") // Added closing brace and semicolon
			}
		} else if testType == "smoke" { // Corrected comparison operator
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTLSVerify: true,\n};\n") // Corrected typo, added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {\n vus: 3, duration: '10s',\n};\n") // Added closing brace and semicolon, example values
			}
		} else if testType == "load" {
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTlsVerify: true,\n};\n") // Added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {};\n") // Added closing brace and semicolon
			}
		} else { // Default case for other test types
			if !config.RequestInputXML.SSLRequired {
				jsCode.WriteString("export const options = {\n insecureSkipTlsVerify: true,\n};\n") // Added closing brace and semicolon
			} else {
				jsCode.WriteString("export const options = {};\n") // Added closing brace and semicolon
			}
		}

		// Corrected loop syntax and variable names
		for _, sessionEndpoint := range config.RequestInputXML.ThreadGroup.SessionEndpoint {
			jsCode.WriteString(fmt.Sprintf("const %s = new Trend('%s'); \n", sessionEndpoint.Title, sessionEndpoint.Title))
		}
		for _, endpoint := range config.RequestInputXML.ThreadGroup.Endpoint {
			jsCode.WriteString(fmt.Sprintf("const %s = new Trend('%s'); \n", endpoint.Title, endpoint.Title)) // Corrected variable name
		}
		jsCode.WriteString("export default function () {\n") // Corrected function syntax

		for sessionEndpointIndex, sessionEndpoint := range config.RequestInputXML.ThreadGroup.SessionEndpoint { // Corrected variable name
			fmt.Printf("######## Title: %s\n", sessionEndpoint.Title) // Read the headers file
			headersData, err := os.ReadFile(vpeconfigFolderPath + sessionEndpoint.HeadersFile)
			if err != nil {
				// log.Fatalf("error: %v", err) // Original code exits
				return fmt.Errorf("failed to read session headers file %s: %w", sessionEndpoint.HeadersFile, err) // Return error
			}

			var headersConfig HeadersConfig
			err = yaml.Unmarshal(headersData, &headersConfig) // Corrected variable name
			if err != nil {
				// log.Fatalf("error: %v", err) // Original code exits
				return fmt.Errorf("failed to unmarshal session headers file %s: %w", sessionEndpoint.HeadersFile, err) // Return error
			}

			jsCode.WriteString(fmt.Sprintf("const session_headers_%d = {\n", sessionEndpointIndex)) // Corrected syntax
			for _, header := range headersConfig.Headers.Header {
				if header.Name != "" {
					// Corrected variable substitution logic
					if !strings.Contains(header.Name, "${") && !strings.Contains(header.Value, "${") {
						jsCode.WriteString(fmt.Sprintf(" '%s': '%s',\n", header.Name, header.Value))
					} else {
						processedName := header.Name
						processedValue := header.Value
						isNameVar := strings.Contains(processedName, "${") && strings.Contains(processedName, "}")
						isValueVar := strings.Contains(processedValue, "${") && strings.Contains(processedValue, "}")

						if isNameVar {
							processedName = strings.ReplaceAll(processedName, "${", "")
							processedName = strings.ReplaceAll(processedName, "}", "")
						}
						if isValueVar {
							processedValue = strings.ReplaceAll(processedValue, "${", "")
							processedValue = strings.ReplaceAll(processedValue, "}", "")
						}

						if isNameVar && isValueVar {
							jsCode.WriteString(fmt.Sprintf(" %s: %s,\n", processedName, processedValue))
						} else if isNameVar && !isValueVar {
							jsCode.WriteString(fmt.Sprintf(" %s: '%s',\n", processedName, processedValue))
						} else if !isNameVar && isValueVar {
							jsCode.WriteString(fmt.Sprintf(" '%s': %s,\n", processedName, processedValue))
						} else {
							// Should not happen if the outer if is correct, but as a fallback
							jsCode.WriteString(fmt.Sprintf(" '%s': '%s',\n", processedName, processedValue))
						}
					}
				}
			}
			jsCode.WriteString("};\n") // Corrected syntax

			var bodyFound bool = false
			var queryArray []string
			var pathVarArray []string
			// Corrected loop syntax and variable name
			for bodyIndex, bodyjson := range sessionEndpoint.BodyJSONs.BodyJSON {
				bodyFound = false // Reset bodyFound for each bodyjson? This seems incorrect. Should be true if any body is found.
				if strings.HasSuffix(bodyjson.Value, ".txt") || strings.HasSuffix(bodyjson.Value, ".json") {
					bodyJSONsData, err := os.ReadFile(vpeconfigFolderPath + bodyjson.Value)
					if err != nil {
						// log.Fatalf("error: %v", err) // Original code exits
						return fmt.Errorf("failed to read session body file %s: %w", bodyjson.Value, err) // Return error
					}
					// Convert bodyJSONsData to string
					bodyJSONsDataStr := string(bodyJSONsData)
					bodyJSONsDataStr = removeNextClosingBrace(bodyJSONsDataStr) // Assuming this function exists
					// bodyJSONsData = []byte(bodyJSONsDataStr) // This line is not needed if you use bodyJSONsDataStr

					jsCode.WriteString(fmt.Sprintf("const session_body_%d_%d = %s;\n", sessionEndpointIndex, bodyIndex, bodyJSONsDataStr)) // Use string
					bodyFound = true
				} else {
					if sessionEndpoint.APIName != "" && strings.Contains(sessionEndpoint.APIName, "{"+bodyjson.Name+"}") {
						pathVarArray = append(pathVarArray, fmt.Sprintf("%s=%s", bodyjson.Name, bodyjson.Value))
					} else {
						queryArray = append(queryArray, fmt.Sprintf("%s=%s", bodyjson.Name, bodyjson.Value))
					}
				}
			}

			if len(pathVarArray) > 0 {
				for _, pathVar := range pathVarArray {
					// Corrected ReplaceAll usage
					sessionEndpoint.APIName = strings.ReplaceAll(sessionEndpoint.APIName, "{"+strings.Split(pathVar, "=")[0]+"}", strings.Split(pathVar, "=")[1])
				}
			}
			// Check if query params are found
			if len(queryArray) > 0 {
				for _, query := range queryArray {
					if strings.Contains(sessionEndpoint.APIName, "?") {
						sessionEndpoint.APIName = sessionEndpoint.APIName + "&" + query
					} else {
						sessionEndpoint.APIName = sessionEndpoint.APIName + "?" + query
					}
				}
			}

			fmt.Printf("Session API Name: %s\n", sessionEndpoint.APIName)
			// Corrected URL construction - assuming Domain is not part of SessionEndpoint
			// If Domain is needed, it must come from VPEConfig or be added to SessionEndpoint struct
			// Assuming APIName is the full path including domain if needed, or relative path
			jsCode.WriteString(fmt.Sprintf("const session_url_%d = '%s';\n", sessionEndpointIndex, sessionEndpoint.APIName)) // Corrected format

			if bodyFound {
				// Corrected function call and variable name
				jsCode.WriteString(fmt.Sprintf("let session_res_%d = http.%s(session_url_%d, JSON.stringify(session_body_%d_0), {headers: session_headers_%d});\n", sessionEndpointIndex, strings.ToLower(sessionEndpoint.Method), sessionEndpointIndex, sessionEndpointIndex, sessionEndpointIndex))
			} else {
				// Corrected function call and variable name
				jsCode.WriteString(fmt.Sprintf("let session_res_%d = http.%s(session_url_%d, {headers: session_headers_%d});\n", sessionEndpointIndex, strings.ToLower(sessionEndpoint.Method), sessionEndpointIndex, sessionEndpointIndex))
			}
			// Corrected variable name
			jsCode.WriteString(fmt.Sprintf("%s.add(session_res_%d.timings.waiting);\n", sessionEndpoint.Title, sessionEndpointIndex))

			jsCode.WriteString(fmt.Sprintf("check(session_res_%d, {\n", sessionEndpointIndex))
			// Corrected variable name and check syntax
			jsCode.WriteString(fmt.Sprintf("'%s_status_200_check': (r) => r.status == 200,\n", sessionEndpoint.Title))

			if sessionEndpoint.ResponseString != "" {
				// Corrected variable name and check syntax
				jsCode.WriteString(fmt.Sprintf("'%s_verify_response_text': (r)=> r.body.includes('%s'),\n", sessionEndpoint.Title, sessionEndpoint.ResponseString))
			}
			jsCode.WriteString("});\n") // Corrected syntax
			jsCode.WriteString("sleep(1);\n")

			if sessionEndpoint.Extracter != "" {
				extracterData, err := os.ReadFile(vpeconfigFolderPath + sessionEndpoint.Extracter)
				if err != nil {
					// log.Fatalf("error: %v", err) // Original code exits
					return fmt.Errorf("failed to read session extracter file %s: %w", sessionEndpoint.Extracter, err) // Return error
				}
				var extracterConfig ExtracterConfig
				err = yaml.Unmarshal(extracterData, &extracterConfig) // Corrected assignment
				if err != nil {
					// log.Fatalf("error: %s", err) // Original code exits
					return fmt.Errorf("failed to unmarshal session extracter file %s: %w", sessionEndpoint.Extracter, err) // Return error
				}
				fmt.Printf("Parsed ExtracterConfig: %+v\n", extracterConfig)

				for _, regexExtract := range extracterConfig.Extracter.RegexExtract {
					if regexExtract.Type == "header" {
						// Corrected variable name and header access
						jsCode.WriteString(fmt.Sprintf("let %s = session_res_%d.headers['%s'];\n", regexExtract.Name, sessionEndpointIndex, strings.Split(regexExtract.Value, ":")[0]))
					} else if regexExtract.Type == "body" { // Corrected comparison operator
						// Corrected variable name and regex usage
						jsCode.WriteString(fmt.Sprintf("let %s = session_res_%d.body.match(/%s/);\n", regexExtract.Name, sessionEndpointIndex, regexExtract.Value))

						if strings.Contains(regexExtract.Value, "privateClaims") { // This condition seems tied to the regex value, not the extracted result
							// This JSON.parse logic seems specific and might need adjustment based on actual regex output
							jsCode.WriteString(fmt.Sprintf("if (%s && %s[1]) { %s[1] = JSON.parse(\"{\"+%s[1]+\"}\"); }\n", regexExtract.Name, regexExtract.Name, regexExtract.Name, regexExtract.Name)) // Added check for existence
						}
					}
				}
			}
		}

		for endpointIndex, endpoint := range config.RequestInputXML.ThreadGroup.Endpoint {
			headersData, err := os.ReadFile(vpeconfigFolderPath + endpoint.HeadersFile)

			if err != nil {
				// log.Fatalf("error: %v", err) // Original code exits
				return fmt.Errorf("failed to read endpoint headers file %s: %w", endpoint.HeadersFile, err) // Return error
			}

			var headersConfig HeadersConfig
			err = yaml.Unmarshal(headersData, &headersConfig) // Corrected variable name
			if err != nil {
				// log.Fatalf("error: %v", err) // Original code exits
				return fmt.Errorf("failed to unmarshal endpoint headers file %s: %w", endpoint.HeadersFile, err) // Return error
			}

			jsCode.WriteString(fmt.Sprintf("const headers_%d = {\n", endpointIndex))
			for _, header := range headersConfig.Headers.Header {
				if header.Name != "" {
					// Corrected variable substitution logic (similar to session headers)
					if !strings.Contains(header.Name, "${") && !strings.Contains(header.Value, "${") {
						jsCode.WriteString(fmt.Sprintf(" '%s': '%s',\n", header.Name, header.Value))
					} else {
						processedName := header.Name
						processedValue := header.Value
						isNameVar := strings.Contains(processedName, "${") && strings.Contains(processedName, "}")
						isValueVar := strings.Contains(processedValue, "${") && strings.Contains(processedValue, "}")

						if isNameVar {
							processedName = strings.ReplaceAll(processedName, "${", "")
							processedName = strings.ReplaceAll(processedName, "}", "")
						}
						if isValueVar {
							processedValue = strings.ReplaceAll(processedValue, "${", "")
							processedValue = strings.ReplaceAll(processedValue, "}", "")
						}

						if isNameVar && isValueVar {
							jsCode.WriteString(fmt.Sprintf(" %s: %s,\n", processedName, processedValue))
						} else if isNameVar && !isValueVar {
							jsCode.WriteString(fmt.Sprintf(" %s: '%s',\n", processedName, processedValue))
						} else if !isNameVar && isValueVar { // Corrected condition
							jsCode.WriteString(fmt.Sprintf(" '%s': %s,\n", processedName, processedValue))
						} else {
							// Should not happen if the outer if is correct, but as a fallback
							jsCode.WriteString(fmt.Sprintf(" '%s': '%s',\n", processedName, processedValue))
						}
					}
				}
			}
			jsCode.WriteString("};\n") // Corrected syntax

			var bodyFound bool = false
			var queryArray []string
			var pathVarArray []string

			// Corrected loop syntax and variable name
			for bodyIndex, bodyjson := range endpoint.BodyJSONs.BodyJSON {
				bodyFound = false // Reset bodyFound for each bodyjson? This seems incorrect. Should be true if any body is found.
				if strings.HasSuffix(bodyjson.Value, ".txt") || strings.HasSuffix(bodyjson.Value, ".json") { // Corrected variable name
					bodyJSONsData, err := os.ReadFile(vpeconfigFolderPath + bodyjson.Value)
					if err != nil {
						// log.Fatalf("error: %v", err) // Original code exits
						return fmt.Errorf("failed to read endpoint body file %s: %w", bodyjson.Value, err) // Return error
					}

					bodyJSONsDataStr := string(bodyJSONsData)
					bodyJSONsDataStr = removeNextClosingBrace(bodyJSONsDataStr) // Assuming this function exists
					// bodyJSONsData = []byte(bodyJSONsDataStr) // This line is not needed

					jsCode.WriteString(fmt.Sprintf("const body_%d_%d = %s;\n", endpointIndex, bodyIndex, bodyJSONsDataStr)) // Use string
					bodyFound = true
				} else {
					if endpoint.APIName != "" && strings.Contains(endpoint.APIName, "{"+bodyjson.Name+"}") {
						pathVarArray = append(pathVarArray, fmt.Sprintf("%s=%s", bodyjson.Name, bodyjson.Value))
					} else {
						queryArray = append(queryArray, fmt.Sprintf("%s=%s", bodyjson.Name, bodyjson.Value))
					}
				}
			}

			if len(pathVarArray) > 0 {
				for _, pathVar := range pathVarArray {
					// Corrected ReplaceAll usage
					endpoint.APIName = strings.ReplaceAll(endpoint.APIName, "{"+strings.Split(pathVar, "=")[0]+"}", strings.Split(pathVar, "=")[1])
				}
			}

			if len(queryArray) > 0 {
				for _, query := range queryArray {
					if strings.Contains(endpoint.APIName, "?") {
						endpoint.APIName = endpoint.APIName + "&" + query
					} else {
						endpoint.APIName = endpoint.APIName + "?" + query
					}
				}
			}

			fmt.Printf("API Name: %s\n", endpoint.APIName) // Corrected print statement
			// Corrected URL construction
			jsCode.WriteString(fmt.Sprintf("const url_%d = '%s%s';\n", endpointIndex, endpoint.Domain, endpoint.APIName)) // Corrected format

			loopCount := endpoint.LoopCount
			if endpoint.ExecuteOnce {
				loopCount = 1
			}
			jsCode.WriteString(fmt.Sprintf("for (let i = 0; i < %d; i++) {\n", loopCount)) // Corrected syntax

			if bodyFound {
				// Corrected function call and variable name
				jsCode.WriteString(fmt.Sprintf("let res_%d = http.%s(url_%d, JSON.stringify(body_%d_0), {headers: headers_%d});\n", endpointIndex, strings.ToLower(endpoint.Method), endpointIndex, endpointIndex, endpointIndex)) // Added headers
			} else {
				// Corrected function call and variable name
				jsCode.WriteString(fmt.Sprintf("let res_%d = http.%s(url_%d, {headers: headers_%d});\n", endpointIndex, strings.ToLower(endpoint.Method), endpointIndex, endpointIndex)) // Corrected syntax
			}

			jsCode.WriteString(fmt.Sprintf("%s.add(res_%d.timings.waiting);\n", endpoint.Title, endpointIndex)) // Corrected variable name
			jsCode.WriteString(fmt.Sprintf("check(res_%d, {\n", endpointIndex))
			// Corrected variable name and check syntax
			jsCode.WriteString(fmt.Sprintf("'%s_status_200_Check': (r) => r.status == 200,\n", endpoint.Title))

			if endpoint.ResponseString != "" {
				// Corrected variable name and check syntax
				jsCode.WriteString(fmt.Sprintf("'%s_verify_response_text': (r) => r.body.includes('%s'),\n", endpoint.Title, endpoint.ResponseString))
			}
			jsCode.WriteString("});\n") // Corrected syntax

			if endpoint.Extracter != "" {
				extracterData, err := os.ReadFile(vpeconfigFolderPath + endpoint.Extracter)
				if err != nil {
					// log.Fatalf("error: %v", err) // Original code exits
					return fmt.Errorf("failed to read endpoint extracter file %s: %w", endpoint.Extracter, err) // Return error
				}
				var extracterConfig ExtracterConfig
				err = yaml.Unmarshal(extracterData, &extracterConfig)
				if err != nil {
					// log.Fatalf("error: %v", err) // Original code exits
					return fmt.Errorf("failed to unmarshal endpoint extracter file %s: %w", endpoint.Extracter, err) // Return error
				}
				fmt.Printf("Parsed ExtracterConfig: %+v\n", extracterConfig)

				for _, regexExtract := range extracterConfig.Extracter.RegexExtract {
					if regexExtract.Type == "header" { // Corrected comparison operator
						// Corrected variable name and header access
						jsCode.WriteString(fmt.Sprintf("let %s = res_%d.headers['%s']; \n", regexExtract.Name, endpointIndex, strings.Split(regexExtract.Value, ":")[0]))
					} else if regexExtract.Type == "body" {
						// Corrected variable name and regex usage
						jsCode.WriteString(fmt.Sprintf("let %s = res_%d.body.match(/%s/);\n", regexExtract.Name, endpointIndex, regexExtract.Value))
						// Assuming the privateClaims logic is needed here too if the regex matches it
						if strings.Contains(regexExtract.Value, "privateClaims") {
							jsCode.WriteString(fmt.Sprintf("if (%s && %s[1]) { %s[1] = JSON.parse(\"{\"+%s[1]+\"}\"); }\n", regexExtract.Name, regexExtract.Name, regexExtract.Name, regexExtract.Name)) // Added check for existence
						}
					}
				}
			}
			jsCode.WriteString("}\n") // Closing brace for the loop
		}
		jsCode.WriteString("}\n") // Closing brace for the export default function

		// Write html summary generating code using WriteString
		jsCode.WriteString("// Generate HTML Report\n")
		jsCode.WriteString("// export function handleSummary(data) {\n") // Corrected syntax
		jsCode.WriteString(" // return {\n")
		jsCode.WriteString(fmt.Sprintf(" // \"%s-summary.html\": htmlReport(data),\n", testType)) // Corrected format string
		jsCode.WriteString(fmt.Sprintf(" // \"%s-summary.json\": JSON.stringify(data),\n", testType))
		jsCode.WriteString(" // };\n")
		jsCode.WriteString("// }\n")

		fileName := fmt.Sprintf("vpe-%s-script.js", testType) // Corrected format string
		fmt.Println(fileName, "has been generated successfully.")
		err = os.WriteFile(filepath.Join(vpeconfigFolderPath, fileName), []byte(jsCode.String()), 0644) // Write to the temp folder
		if err != nil {
			// log.Fatalf("error: %v", err) // Original code exits
			return fmt.Errorf("failed to write K6 script file %s: %w", fileName, err) // Return error
		}
		fmt.Println("=========================================================")
	} // Closing brace for the testTypeList loop

	// This part is outside the loop, but uses the last testType
	// The original code had a redeclaration of err here
	err = loadEnvVars(filepath.Join(vpeconfigFolderPath, "env_vars")) // Use folder path
	if err != nil {
		fmt.Printf("Error loading env_vars file: %s\n", err)
		return nil // Original code returns nil here
	}
	dl := os.Getenv("D1") // Corrected to get D1, not Dl
	fmt.Println("Email", dl)

	// This print statement is inside the loop in the original code, but makes more sense outside
	// fmt.Println("Validating the generated", fileName, "test") // fileName is only valid inside the loop

	fmt.Println("All files validated") // This print is misleading as no validation happens here
	return nil
}

// --- Test Script Starts Here ---

func Test_validateVpeconfigAndFiles(t *testing.T) {
	// Create a temporary directory for test files
	tempDir, err := ioutil.TempDir("", "vpeconfig_test")
	if err != nil {
		t.Fatalf("Failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tempDir) // Clean up the temporary directory

	// Helper function to create files in the temporary directory
	createFile := func(t *testing.T, filename string, content string) {
		filePath := filepath.Join(tempDir, filename)
		err := ioutil.WriteFile(filePath, []byte(content), 0644)
		if err != nil {
			t.Fatalf("Failed to create file %s: %v", filename, err)
		}
	}

	// Test Case 1: Successful execution with minimal config
	t.Run("SuccessMinimalConfig", func(t *testing.T) {
		// Create dummy files
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "smoke"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "HomePage"
        HeadersFile: "headers/home.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/home"
        Method: "GET"
        ResponseString: "Welcome"
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `
Headers:
  Header:
    - Name: "Content-Type"
      Value: "application/json"
`
		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755) // Create headers directory
		createFile(t, "headers/home.yml", headersContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check if env_vars file was created and its content
		envVarsPath := filepath.Join(tempDir, "env_vars")
		if _, err := os.Stat(envVarsPath); os.IsNotExist(err) {
			t.Error("env_vars file was not created")
		} else {
			envVarsContent, err := ioutil.ReadFile(envVarsPath)
			if err != nil {
				t.Errorf("Failed to read env_vars file: %v", err)
			}
			expectedEnvVarsContent := `export ApplnName="TestApp"
export MicroserviceName="TestService"
export TestType="smoke"
export Dl="test@example.com"
`
			if string(envVarsContent) != expectedEnvVarsContent {
				t.Errorf("env_vars content mismatch.\nExpected:\n%s\nGot:\n%s", expectedEnvVarsContent, string(envVarsContent))
			}
		}

		// Check if K6 script file was created and its content (basic check)
		scriptFileName := "vpe-smoke-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			// Perform basic checks on script content
			scriptString := string(scriptContent)
			if !strings.Contains(scriptString, "import http from 'k6/http';") {
				t.Error("K6 script missing http import")
			}
			if !strings.Contains(scriptString, "//testType=smoke") {
				t.Error("K6 script missing testType comment")
			}
			if !strings.Contains(scriptString, "//vusers=10") {
				t.Error("K6 script missing vusers comment")
			}
			if !strings.Contains(scriptString, "export const options = {\n insecureSkipTLSVerify: true,\n};") {
				t.Error("K6 script missing expected options for smoke/SSL=false")
			}
			if !strings.Contains(scriptString, "const HomePage = new Trend('HomePage');") {
				t.Error("K6 script missing Trend for HomePage")
			}
			if !strings.Contains(scriptString, "export default function () {") {
				t.Error("K6 script missing default function")
			}
			if !strings.Contains(scriptString, "const headers_0 = {") {
				t.Error("K6 script missing headers definition")
			}
			if !strings.Contains(scriptString, "'Content-Type': 'application/json',") {
				t.Error("K6 script missing expected header")
			}
			if !strings.Contains(scriptString, "const url_0 = 'http://localhost/home';") {
				t.Error("K6 script missing expected URL")
			}
			if !strings.Contains(scriptString, "let res_0 = http.get(url_0, {headers: headers_0});") {
				t.Error("K6 script missing expected http call")
			}
			if !strings.Contains(scriptString, "HomePage.add(res_0.timings.waiting);") {
				t.Error("K6 script missing Trend add")
			}
			if !strings.Contains(scriptString, "check(res_0, {") {
				t.Error("K6 script missing check block")
			}
			if !strings.Contains(scriptString, "'HomePage_status_200_Check': (r) => r.status == 200,") {
				t.Error("K6 script missing status check")
			}
			if !strings.Contains(scriptString, "'HomePage_verify_response_text': (r) => r.body.includes('Welcome'),") {
				t.Error("K6 script missing response string check")
			}
			if !strings.Contains(scriptString, "sleep(1);") {
				t.Error("K6 script missing sleep")
			}
			if !strings.Contains(scriptString, "for (let i = 0; i < 1; i++) {") {
				t.Error("K6 script missing expected loop")
			}
		}

		// Check environment variables set by the function
		if os.Getenv("ApplnName") != "TestApp" {
			t.Errorf("Expected ApplnName env var to be 'TestApp', but got '%s'", os.Getenv("ApplnName"))
		}
		if os.Getenv("MicroserviceName") != "TestService" {
			t.Errorf("Expected MicroserviceName env var to be 'TestService', but got '%s'", os.Getenv("MicroserviceName"))
		}
		if os.Getenv("TestType") != "smoke" {
			t.Errorf("Expected TestType env var to be 'smoke', but got '%s'", os.Getenv("TestType"))
		}
		if os.Getenv("D1") != "test@example.com" { // Corrected to check D1
			t.Errorf("Expected D1 env var to be 'test@example.com', but got '%s'", os.Getenv("D1"))
		}
	})

	// Test Case 2: Config.yml missing
	t.Run("ConfigMissing", func(t *testing.T) {
		// Call the function with a path where Config.yml doesn't exist
		err := validateVpeconfigAndFiles(tempDir)

		// Check the error
		if err == nil {
			t.Error("Expected an error when Config.yml is missing, but got nil")
		} else {
			expectedErrorSubstring := "failed to read VPEConfig.yml:"
			if !strings.Contains(err.Error(), expectedErrorSubstring) {
				t.Errorf("Expected error message to contain '%s', but got '%s'", expectedErrorSubstring, err.Error())
			}
		}

		// Check that no files were created
		envVarsPath := filepath.Join(tempDir, "env_vars")
		if _, err := os.Stat(envVarsPath); !os.IsNotExist(err) {
			t.Error("env_vars file was created unexpectedly")
		}
		scriptPath := filepath.Join(tempDir, "vpe-*-script.js") // Use wildcard as filename depends on config
		matches, _ := filepath.Glob(scriptPath)
		if len(matches) > 0 {
			t.Errorf("K6 script file(s) were created unexpectedly: %v", matches)
		}
	})

	// Test Case 3: Config.yml with invalid YAML
	// NOTE: The original function uses log.Fatalf for YAML unmarshalling errors.
	// This test will cause the program to exit if the original function is used.
	// If the function were refactored to return an error, this test would pass.
	t.Run("ConfigInvalidYAML_Exits", func(t *testing.T) {
		t.Skip("Skipping test that causes program exit due to log.Fatalf in the original function")
		// Create dummy file with invalid YAML
		invalidConfigContent := `
RequestInputXML:
  ApplnName: "TestApp"
  InvalidField: [ - ] # Invalid YAML syntax
`
		createFile(t, "Config.yml", invalidConfigContent)

		// Call the function - this is expected to cause log.Fatalf and exit
		// We cannot assert a returned error here with the original function
		// A real test would need to capture os.Exit or mock log.Fatalf
		validateVpeconfigAndFiles(tempDir)

		// If the test reaches here, it means log.Fatalf did NOT exit, which is unexpected
		t.Error("Function did not exit as expected with invalid YAML")
	})

	// Test Case 4: Missing referenced Headers file (expected to exit)
	t.Run("MissingHeadersFile_Exits", func(t *testing.T) {
		t.Skip("Skipping test that causes program exit due to log.Fatalf in the original function")
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "smoke"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "HomePage"
        HeadersFile: "headers/non_existent.yml" # This file does not exist
        BodyJSONs:
          BodyJSON: []
        APIName: "/home"
        Method: "GET"
        ResponseString: "Welcome"
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		createFile(t, "Config.yml", configContent)
		// Do NOT create headers/non_existent.yml

		// Call the function - expected to cause log.Fatalf and exit
		validateVpeconfigAndFiles(tempDir)

		t.Error("Function did not exit as expected when headers file is missing")
	})

	// Test Case 5: Missing referenced Body JSON file (expected to exit)
	t.Run("MissingBodyJSONFile_Exits", func(t *testing.T) {
		t.Skip("Skipping test that causes program exit due to log.Fatalf in the original function")
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "smoke"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "HomePage"
        HeadersFile: "headers/home.yml"
        BodyJSONs:
          BodyJSON:
            - Name: "data"
              Value: "bodies/non_existent.json" # This file does not exist
        APIName: "/home"
        Method: "POST"
        ResponseString: ""
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `Headers: { Header: [] }`
		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/home.yml", headersContent)
		os.MkdirAll(filepath.Join(tempDir, "bodies"), 0755)
		// Do NOT create bodies/non_existent.json

		// Call the function - expected to cause log.Fatalf and exit
		validateVpeconfigAndFiles(tempDir)

		t.Error("Function did not exit as expected when body JSON file is missing")
	})

	// Test Case 6: Missing referenced Extracter file (expected to exit)
	t.Run("MissingExtracterFile_Exits", func(t *testing.T) {
		t.Skip("Skipping test that causes program exit due to log.Fatalf in the original function")
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "smoke"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "HomePage"
        HeadersFile: "headers/home.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/home"
        Method: "GET"
        ResponseString: ""
        Extracter: "extracters/non_existent.yml" # This file does not exist
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `Headers: { Header: [] }`
		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/home.yml", headersContent)
		os.MkdirAll(filepath.Join(tempDir, "extracters"), 0755)
		// Do NOT create extracters/non_existent.yml

		// Call the function - expected to cause log.Fatalf and exit
		validateVpeconfigAndFiles(tempDir)

		t.Error("Function did not exit as expected when extracter file is missing")
	})

	// Test Case 7: ThreadLoadPercentage < 100
	t.Run("ThreadLoadPercentageLessThan100", func(t *testing.T) {
		vusers := 100
		percentage := 50
		configContent := fmt.Sprintf(`
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "load"
  DL: "test@example.com"
  VUsers: %d
  SSLRequired: true
  ThreadGroup:
    ThreadLoadPercentage: %d
    SessionEndpoint: []
    Endpoint: []
`, vusers, percentage)

		createFile(t, "Config.yml", configContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check if K6 script file was created and its content (check vusers comment)
		scriptFileName := "vpe-load-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)
			// Expected vusers after calculation: (100 * 50) / 100 = 50
			expectedVusersComment := "//vusers=50"
			if !strings.Contains(scriptString, expectedVusersComment) {
				t.Errorf("K6 script missing expected vusers comment after percentage calculation.\nExpected substring: '%s'\nGot script:\n%s", expectedVusersComment, scriptString)
			}
		}
	})

	// Test Case 8: Multiple TestTypes
	t.Run("MultipleTestTypes", func(t *testing.T) {
		testTypes := "smoke, load, sanity"
		configContent := fmt.Sprintf(`
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "%s"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint: []
`, testTypes)

		createFile(t, "Config.yml", configContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check if multiple script files were created
		expectedFiles := []string{"vpe-smoke-script.js", "vpe-load-script.js", "vpe-sanity-script.js"}
		for _, fileName := range expectedFiles {
			filePath := filepath.Join(tempDir, fileName)
			if _, err := os.Stat(filePath); os.IsNotExist(err) {
				t.Errorf("%s file was not created", fileName)
			}
		}
	})

	// Test Case 9: SSLRequired = true
	t.Run("SSLRequiredTrue", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "smoke"
  DL: "test@example.com"
  VUsers: 10
  SSLRequired: true
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint: []
`
		createFile(t, "Config.yml", configContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for options block
		scriptFileName := "vpe-smoke-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)
			// For smoke/SSL=true, the options block should be empty
			if !strings.Contains(scriptString, "export const options = {};") {
				t.Errorf("K6 script missing expected options for smoke/SSL=true.\nExpected substring: 'export const options = {};'\nGot script:\n%s", scriptString)
			}
		}
	})

	// Test Case 10: Endpoint with Body JSON file (.json)
	t.Run("EndpointWithBodyJSONFile", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "functional"
  DL: "test@example.com"
  VUsers: 1
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "Login"
        HeadersFile: "headers/login.yml"
        BodyJSONs:
          BodyJSON:
            - Name: "credentials"
              Value: "bodies/login.json"
        APIName: "/login"
        Method: "POST"
        ResponseString: "success"
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `Headers: { Header: [] }`
		bodyJSONContent := `{"username": "test", "password": "password"}`

		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/login.yml", headersContent)
		os.MkdirAll(filepath.Join(tempDir, "bodies"), 0755)
		createFile(t, "bodies/login.json", bodyJSONContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for body handling
		scriptFileName := "vpe-functional-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)

			expectedBodyConst := `const body_0_0 = {"username": "test", "password": "password"};` // Assuming removeNextClosingBrace doesn't change this
			if !strings.Contains(scriptString, expectedBodyConst) {
				t.Errorf("K6 script missing expected body constant.\nExpected substring: '%s'\nGot script:\n%s", expectedBodyConst, scriptString)
			}

			expectedHttpPost := `let res_0 = http.post(url_0, JSON.stringify(body_0_0), {headers: headers_0});`
			if !strings.Contains(scriptString, expectedHttpPost) {
				t.Errorf("K6 script missing expected http.post call with body.\nExpected substring: '%s'\nGot script:\n%s", expectedHttpPost, scriptString)
			}
		}
	})

	// Test Case 11: Endpoint with Path Variable and Query Parameter
	t.Run("EndpointWithPathAndQuery", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "functional"
  DL: "test@example.com"
  VUsers: 1
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "GetUser"
        HeadersFile: "headers/get.yml"
        BodyJSONs:
          BodyJSON:
            - Name: "userId"
              Value: "123"
            - Name: "status"
              Value: "active"
        APIName: "/users/{userId}"
        Method: "GET"
        ResponseString: ""
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `Headers: { Header: [] }`

		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/get.yml", headersContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for URL construction
		scriptFileName := "vpe-functional-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)

			// Expected URL: /users/123?status=active
			expectedURLConst := `const url_0 = 'http://localhost/users/123?status=active';`
			if !strings.Contains(scriptString, expectedURLConst) {
				t.Errorf("K6 script missing expected URL with path variable and query parameter.\nExpected substring: '%s'\nGot script:\n%s", expectedURLConst, scriptString)
			}
		}
	})

	// Test Case 12: Header with variable substitution
	t.Run("HeaderVariableSubstitution", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "functional"
  DL: "test@example.com"
  VUsers: 1
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "TestHeader"
        HeadersFile: "headers/vars.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/test"
        Method: "GET"
        ResponseString: ""
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		// Assuming 'myVar' is a variable that would be defined elsewhere in the K6 script
		headersContent := `
Headers:
  Header:
    - Name: "X-Custom-Header"
      Value: "${myVar}"
    - Name: "${anotherVar}"
      Value: "someValue"
    - Name: "${combinedVar}"
      Value: "${anotherValue}"
    - Name: "StaticHeader"
      Value: "staticValue"
`
		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/vars.yml", headersContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for header definition
		scriptFileName := "vpe-functional-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)

			expectedHeaders := `const headers_0 = {
 'X-Custom-Header': myVar,
 anotherVar: 'someValue',
 combinedVar: anotherValue,
 'StaticHeader': 'staticValue',
};` // Note the formatting difference for variables vs static strings
			if !strings.Contains(scriptString, expectedHeaders) {
				t.Errorf("K6 script missing expected headers with variable substitution.\nExpected substring: '%s'\nGot script:\n%s", expectedHeaders, scriptString)
			}
		}
	})

	// Test Case 13: Endpoint with Extracter (header and body)
	t.Run("EndpointWithExtracter", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "functional"
  DL: "test@example.com"
  VUsers: 1
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "ExtractTest"
        HeadersFile: "headers/get.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/extract"
        Method: "GET"
        ResponseString: ""
        Extracter: "extracters/extract.yml"
        Domain: "http://localhost"
        LoopCount: 1
        ExecuteOnce: false
`
		headersContent := `Headers: { Header: [] }`
		extracterContent := `
Extracter:
  RegexExtract:
    - Name: "authHeader"
      Type: "header"
      Value: "Authorization: Bearer (.*)" # Value format seems inconsistent with usage
    - Name: "itemId"
      Type: "body"
      Value: '"id":\s*(\d+)' # Regex to capture ID
    - Name: "privateClaims"
      Type: "body"
      Value: '"privateClaims":\s*({.*?})' # Regex to capture JSON object
`
		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/get.yml", headersContent)
		os.MkdirAll(filepath.Join(tempDir, "extracters"), 0755)
		createFile(t, "extracters/extract.yml", extracterContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for extracter logic
		scriptFileName := "vpe-functional-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)

			// Check header extraction
			// The original code uses strings.Split(regexExtract.Value, ":")[0] which is "Authorization"
			expectedHeaderExtract := `let authHeader = res_0.headers['Authorization'];`
			if !strings.Contains(scriptString, expectedHeaderExtract) {
				t.Errorf("K6 script missing expected header extraction.\nExpected substring: '%s'\nGot script:\n%s", expectedHeaderExtract, scriptString)
			}

			// Check body extraction (regex match)
			// The original code uses regexExtract.Value directly as the regex pattern
			expectedBodyExtractItem := `let itemId = res_0.body.match(/"id":\s*(\d+)/);`
			if !strings.Contains(scriptString, expectedBodyExtractItem) {
				t.Errorf("K6 script missing expected body extraction for itemId.\nExpected substring: '%s'\nGot script:\n%s", expectedBodyExtractItem, scriptString)
			}

			expectedBodyExtractClaims := `let privateClaims = res_0.body.match(/"privateClaims":\s*({.*?})/);`
			if !strings.Contains(scriptString, expectedBodyExtractClaims) {
				t.Errorf("K6 script missing expected body extraction for privateClaims.\nExpected substring: '%s'\nGot script:\n%s", expectedBodyExtractClaims, scriptString)
			}

			// Check JSON.parse logic for privateClaims
			expectedJsonParse := `if (privateClaims && privateClaims[1]) { privateClaims[1] = JSON.parse("{" + privateClaims[1] + "}"); }`
			if !strings.Contains(scriptString, expectedJsonParse) {
				t.Errorf("K6 script missing expected JSON.parse logic for privateClaims.\nExpected substring: '%s'\nGot script:\n%s", expectedJsonParse, scriptString)
			}
		}
	})

	// Test Case 14: Endpoint with LoopCount and ExecuteOnce
	t.Run("EndpointLoopCountAndExecuteOnce", func(t *testing.T) {
		configContent := `
RequestInputXML:
  ApplnName: "TestApp"
  MicroserviceName: "TestService"
  TestType: "functional"
  DL: "test@example.com"
  VUsers: 1
  SSLRequired: false
  ThreadGroup:
    ThreadLoadPercentage: 100
    SessionEndpoint: []
    Endpoint:
      - Title: "LoopTest"
        HeadersFile: "headers/get.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/loop"
        Method: "GET"
        ResponseString: ""
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 5
        ExecuteOnce: false
      - Title: "OnceTest"
        HeadersFile: "headers/get.yml"
        BodyJSONs:
          BodyJSON: []
        APIName: "/once"
        Method: "GET"
        ResponseString: ""
        Extracter: ""
        Domain: "http://localhost"
        LoopCount: 10 # Should be ignored due to ExecuteOnce
        ExecuteOnce: true
`
		headersContent := `Headers: { Header: [] }`

		createFile(t, "Config.yml", configContent)
		os.MkdirAll(filepath.Join(tempDir, "headers"), 0755)
		createFile(t, "headers/get.yml", headersContent)

		// Call the function
		err := validateVpeconfigAndFiles(tempDir)

		// Check the result
		if err != nil {
			t.Errorf("Expected no error, but got: %v", err)
		}

		// Check K6 script content for loop structures
		scriptFileName := "vpe-functional-script.js"
		scriptPath := filepath.Join(tempDir, scriptFileName)
		if _, err := os.Stat(scriptPath); os.IsNotExist(err) {
			t.Errorf("%s file was not created", scriptFileName)
		} else {
			scriptContent, err := ioutil.ReadFile(scriptPath)
			if err != nil {
				t.Errorf("Failed to read %s file: %v", scriptFileName, err)
			}
			scriptString := string(scriptContent)

			// Check loop for LoopTest (LoopCount = 5, ExecuteOnce = false)
			expectedLoopTest := `for (let i = 0; i < 5; i++) {`
			if !strings.Contains(scriptString, expectedLoopTest) {
				t.Errorf("K6 script missing expected loop for LoopTest.\nExpected substring: '%s'\nGot script:\n%s", expectedLoopTest, scriptString)
			}

			// Check loop for OnceTest (LoopCount = 10, ExecuteOnce = true)
			expectedLoopOnce := `for (let i = 0; i < 1; i++) {` // Should be 1 due to ExecuteOnce
			if !strings.Contains(scriptString, expectedLoopOnce) {
				t.Errorf("K6 script missing expected loop for OnceTest (ExecuteOnce).\nExpected substring: '%s'\nGot script:\n%s", expectedLoopOnce, scriptString)
			}
		}
	})

	// Add more test cases for other scenarios:
	// - SessionEndpoint logic (similar tests as Endpoint)
	// - Body JSON file type .txt
	// - Body JSON inline values
	// - Different HTTP methods (POST, PUT, etc.)
	// - Empty ThreadGroup.SessionEndpoint and ThreadGroup.Endpoint
	// - Config with nil optional fields (ApiErrors, ResponseTime, Duration, VUsers)
	// - Invalid content in referenced files (e.g., invalid JSON in body file - expected to exit)
	// - Edge cases for ThreadLoadPercentage (0, negative - though schema might prevent this)
	// - Edge cases for LoopCount (0, negative - though schema might prevent this)
}
