import { browser } from 'k6/browser';
import { check, group, sleep as k6Sleep } from 'k6';
import { Trend } from 'k6/metrics';
import { htmlReport } from "https://raw.githubusercontent.com/benc-uk/k6-reporter/main/dist/bundle.js";

// ------------------ CONFIG ------------------
const stepTrends = {};

export const options = {
  scenarios: {
    ui: {
      executor: "constant-vus",
      vus: 1,
      duration: '1m',
      options: {
        browser: {
          type: "chromium",
          headless: true,
        },
      },
    },
  },
  thresholds: {},
};

// ------------------ TEST CONFIG ------------------
const userConfig = {
  baseUrl: "https://grafana.com",
  transactions: [
    {
      name: "Grafana Navigation",
      steps: [
        { name: "Navigate to Grafana Home", action: "goto", url: "/", screenshot: true },
        { name: "Click Open Source Menu", action: "click", selector: "xpath=/html/body/header/div[1]/div/ul[1]/li/a[2]", screenshot: true },
        { name: "Click Grafana k6 Link", action: "click", selector: "xpath=/html/body/header/div[2]/div/div[2]/div/div/div[3]/div/div[1]/a[1]/div/div/p[1]", screenshot: true },
        { name: "Click Get Started Button", action: "click", selector: "xpath=/html/body/div[2]/div/div[6]/div/div/div[2]/div[1]/div/div/div[2]/div[2]/a", screenshot: true },
        { name: "Click Chocolatey Package Manager", action: "click", selector: "xpath=//*[@id=\"doc-article-text\"]/p[5]/a", screenshot: true },
        { name: "Verify Chocolatey Section Visible", action: "check", selector: "xpath=//h2[contains(text(),'Chocolatey')]", screenshot: true },
      ],
    },
  ],
};

// ------------------ INIT TRENDS ------------------
userConfig.transactions.forEach(transaction => {
  transaction.steps.forEach(step => {
    const trendName = `${step.name.replace(/[^a-zA-Z0-9]/g, '_')}_${step.action}`;
    stepTrends[step.name] = new Trend(trendName, true);
  });
});

// ------------------ HELPERS ------------------
const safeVisible = async (locator) => {
  try { return await locator.isVisible(); } 
  catch (e) { return false; }
};

// Auto-scroll just enough to bring element into view
const autoScrollToElement = async (locator) => {
  const visible = await safeVisible(locator);
  if (!visible) {
    await locator.evaluate(el => el.scrollIntoView({ behavior: 'smooth', block: 'center' }));
    k6Sleep(0.5);
  }
};

// Wait until next step's selector is visible after click
const waitForVisibleNextStep = async (page, nextSelector, timeout = 10000) => {
  if (!nextSelector) return;
  const locator = page.locator(nextSelector);
  try {
    await locator.waitFor({ state: 'visible', timeout });
  } catch (e) {
    console.log(`‚ö†Ô∏è Next element not visible after click: ${nextSelector}`);
  }
};

// Retry step if element not visible (max 3 attempts)
const executeStepWithRetry = async (page, step, nextSelector, maxRetries = 3) => {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      await executeAction(page, step);
      if (step.action === 'click' && nextSelector) {
        await waitForVisibleNextStep(page, nextSelector, 15000);
      }
      return true; // success
    } catch (err) {
      attempt++;
      if (attempt >= maxRetries) throw err;
      console.log(`‚ö†Ô∏è Retry ${attempt} for step "${step.name}" due to: ${err.message}`);
      k6Sleep(1);
    }
  }
};

// Execute action per step
const executeAction = async (page, step) => {
  const { action, selector, url, value } = step;

  switch (action) {
    case "goto":
      console.log(`üåê Navigating to: ${url}`);
      await page.goto(url.startsWith('http') ? url : `${userConfig.baseUrl}${url}`, { timeout: 30000 });
      k6Sleep(1);
      return true;

    case "click":
      console.log(`üñ±Ô∏è Clicking: ${selector}`);
      const clickLocator = page.locator(selector);
      await autoScrollToElement(clickLocator);
      await clickLocator.waitFor({ state: 'visible', timeout: 10000 });

      // Remove target="_blank" to stay in same window
      await page.evaluate((sel) => {
        const el = document.evaluate(sel.replace('xpath=', ''), document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
        if (el && el.tagName === 'A') el.removeAttribute('target');
      }, selector);

      await clickLocator.click();
      k6Sleep(1);
      return true;

    case "type":
      console.log(`‚å®Ô∏è Typing in: ${selector}`);
      const typeLocator = page.locator(selector);
      await autoScrollToElement(typeLocator);
      await typeLocator.waitFor({ state: 'visible', timeout: 10000 });
      await typeLocator.fill(value);
      k6Sleep(1);
      return true;

    case "check":
      console.log(`üîç Checking: ${selector}`);
      const checkLocator = page.locator(selector);
      await autoScrollToElement(checkLocator);
      await checkLocator.waitFor({ state: 'visible', timeout: 15000 });
      if (!(await safeVisible(checkLocator))) throw new Error(`Element not visible - ${selector}`);
      k6Sleep(0.5);
      return true;

    case "scroll":
      console.log(`üîÉ Scrolling by: ${value}px`);
      await page.evaluate(y => window.scrollBy(0, y), parseInt(value));
      k6Sleep(1);
      return true;

    default:
      throw new Error(`Unknown action: ${action}`);
  }
};

// ------------------ MAIN TEST ------------------
export default async function () {
  const page = await browser.newPage();

  // Single-window enforcement
  await page.evaluate(() => {
    window.open = (url) => { window.location.href = url; };
    document.querySelectorAll("a[target='_blank']").forEach(a => a.removeAttribute("target"));
  });

  await page.setViewportSize({ width: 1280, height: 800 });
  page.setDefaultTimeout(30000);
  page.setDefaultNavigationTimeout(30000);

  try {
    for (let t = 0; t < userConfig.transactions.length; t++) {
      const transaction = userConfig.transactions[t];
      const groupName = transaction.name;
      let groupSuccess = true;
      console.log(`\nüéØ GROUP: ${groupName}`);

      const stepResults = [];

      for (let s = 0; s < transaction.steps.length; s++) {
        const step = transaction.steps[s];
        const nextStep = transaction.steps[s + 1];
        const nextSelector = nextStep ? nextStep.selector : null;

        const startTime = Date.now();
        let stepSuccess = false;
        let errorMessage = '';

        try {
          await executeStepWithRetry(page, step, nextSelector, 3);
          stepSuccess = true;
          console.log(`‚úÖ PASS: ${step.name}`);
        } catch (error) {
          stepSuccess = false;
          errorMessage = error.message;
          groupSuccess = false;
          console.log(`‚ùå FAIL: ${step.name} - ${errorMessage}`);
        }

        const duration = Date.now() - startTime;
        stepTrends[step.name].add(duration, { status: stepSuccess ? 'passed' : 'failed', action: step.action, group: groupName });

        if (step.screenshot) {
          const screenshotName = `${groupName.replace(/[^a-zA-Z0-9]/g, '_')}_${step.name.replace(/[^a-zA-Z0-9]/g, '_')}_${stepSuccess ? 'PASS' : 'FAIL'}.png`;
          try { await page.screenshot({ path: screenshotName }); } 
          catch (e) { console.log(`‚ö†Ô∏è Could not take screenshot: ${e.message}`); }
        }

        stepResults.push({ name: step.name, success: stepSuccess, skipped: false });
      }

      // Register group checks
      group(groupName, () => {
        stepResults.forEach(result => {
          check(null, { [result.name]: () => result.success });
        });
      });

      console.log(`üìä Group ${groupName} completed with: ${groupSuccess ? 'SUCCESS' : 'FAILURE'}`);
    }

    console.log("\nüéâ All test groups completed");
  } catch (error) {
    console.error(`üí• Critical error: ${error.message}`);
  } finally {
    try { await page.close(); } 
    catch (e) { console.error(`‚ö†Ô∏è Error closing browser: ${e.message}`); }
  }
};

// ------------------ SUMMARY ------------------
export function handleSummary(data) {
  return {
    "summary.html": htmlReport(data),
    "summary.json": JSON.stringify(data),
  };
}
