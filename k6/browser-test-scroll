import { browser } from 'k6/browser';
import { check, group, sleep as k6Sleep } from 'k6';
import { Trend } from 'k6/metrics';
import { htmlReport } from "https://raw.githubusercontent.com/benc-uk/k6-reporter/main/dist/bundle.js";

// Create trend metrics for each step
const stepTrends = {};
export const options = {
  scenarios: {
    ui: {
      executor: "shared-iterations",
      vus: 1,
      iterations: 1,
      options: {
        browser: {
          type: "chromium",
          headless: true,
        },
      },
    },
  },
  thresholds: {},
};
// Configuration
const userConfig = {
  baseUrl: "https://grafana.com",
  transactions: [
    {
      name: "Grafana Navigation",
      steps: [
        {
          name: "Navigate to Grafana Home",
          action: "goto",
          url: "/",
          screenshot: true,
        },
        {
          name: "Click Open Source Menu",
          action: "click",
          selector: "xpath=/html/body/header/div[1]/div/ul[1]/li/a[2]",
          screenshot: true,
          waitForLoadState: true
        },
        {
          name: "Click Grafana k6 Link",
          action: "click",
          selector: "xpath=/html/body/header/div[2]/div/div[2]/div/div/div[3]/div/div[1]/a[1]/div/div/p[1]",
          screenshot: true,
          waitForLoadState: true,
        },
        {
          name: "Scroll on Grafana k6 Page",
          action: "scroll",
          value: "800",
          screenshot: true,
        },
        {
          name: "Click Get Started Button",
          action: "click",
          selector: "xpath=/html/body/div[2]/div/div[6]/div/div/div[2]/div[1]/div/div/div[2]/div[2]/a",
          screenshot: true,
          waitForLoadState: true,
        },
        {
          name: "Scroll on Installation Page",
          action: "scroll",
          value: "1000",
          screenshot: true,
        },
        {
          name: "Click Chocolatey Package Manager",
          action: "click",
          selector: "xpath=//*[@id=\"doc-article-text\"]/p[5]/a",
          screenshot: true,
          waitForLoadState: true,
        },
        {
          name: "Verify Chocolatey Section Visible",
          action: "check",
          selector: "xpath=//h2[contains(text(),'Chocolatey')]",
          screenshot: true,
        },
      ],
    }
  ],
};



// Initialize trends for all steps
userConfig.transactions.forEach(transaction => {
  transaction.steps.forEach(step => {
    const trendName = `${step.name.replace(/[^a-zA-Z0-9]/g, '_')}_${step.action}`;
    stepTrends[step.name] = new Trend(trendName, true);
  });
});

export default async function () {
  const baseURL = userConfig.baseUrl;
  const page = await browser.newPage();
  
  try {
    console.log("> Launching browser...");
    await page.setViewportSize({ width: 1280, height: 800 });
    page.setDefaultTimeout(30000);
    page.setDefaultNavigationTimeout(30000);

    let allStepsPassed = true;

    // Execute all test groups
    for (const transaction of userConfig.transactions) {
      const groupName = transaction.name;
      let groupSuccess = true;
      
      console.log(`\nðŸŽ¯ GROUP: ${groupName}`);
      
      // Execute steps and collect results
      const stepResults = [];
      
      for (let i = 0; i < transaction.steps.length; i++) {
        const step = transaction.steps[i];

        const startTime = Date.now();
        let stepSuccess = false;
        let errorMessage = '';

        try {
          // Execute the step action with await
          await executeAction(page, baseURL, step);
          stepSuccess = true;
          console.log(`âœ… PASS: ${step.name}`);
        } catch (error) {
          stepSuccess = false;
          errorMessage = error.message;
          groupSuccess = false;
          allStepsPassed = false;
          console.log(`âŒ FAIL: ${step.name} - ${errorMessage}`);
        }

        const duration = Date.now() - startTime;

        // Record trend metric
        stepTrends[step.name].add(duration, { 
          status: stepSuccess ? 'passed' : 'failed',
          action: step.action,
          group: groupName
        });

        // Take screenshot if requested (take on both success and failure for debugging)
        if (step.screenshot) {
          try {
            const screenshotName = `${groupName.replace(/[^a-zA-Z0-9]/g, '_')}_${step.name.replace(/[^a-zA-Z0-9]/g, '_')}_${stepSuccess ? 'PASS' : 'FAIL'}.png`;
            await page.screenshot({ path: `${screenshotName}` });
            console.log(`ðŸ“¸ Screenshot: ${screenshotName}`);
          } catch (e) {
            console.log(`âš ï¸  Could not take screenshot: ${e.message}`);
          }
        }

        // Store result for group check
        stepResults.push({
          name: step.name,
          success: stepSuccess,
          skipped: false
        });

        // Continue to next step regardless of failure
      }

      // Now register all checks within a group (synchronous)
      group(groupName, () => {
        stepResults.forEach(result => {
          check(null, {
            [result.name]: () => result.success
          });
        });
      });

      console.log(`ðŸ“Š Group ${groupName} completed with: ${groupSuccess ? 'SUCCESS' : 'FAILURE'}`);
    }

    console.log("\nðŸŽ‰ All test groups completed");

  } catch (error) {
    console.error(`ðŸ’¥ Critical error during test execution: ${error.message}`);
  } finally {
    try {
      await page.close();
      console.log("ðŸ”š Browser closed");
    } catch (e) {
      console.error(`âš ï¸ Error closing browser: ${e.message}`);
    }
  }
}

// Helper function to check element visibility
const safeVisible = async (locator) => {
  try {
    return await locator.isVisible();
  } catch (e) {
    return false;
  }
};

// Auto-scroll until element is visible
const autoScrollToElement = async (page, locator) => {
  const maxScrolls = 20;           // prevent infinite scrolling
  const scrollAmount = 400;        // px per scroll

  for (let i = 0; i < maxScrolls; i++) {
    if (await locator.isVisible()) {
      return true; // Element is now visible
    }

    console.log(`ðŸ”ƒ Auto-scrolling... attempt ${i + 1}`);
    await page.evaluate(y => window.scrollBy(0, y), scrollAmount);
    k6Sleep(0.3);
  }

  throw new Error("Element not visible even after auto-scrolling");
};


// Async function to execute actions
const executeAction = async (page, baseURL, step) => {
  const { action, selector, url, value, waitForLoadState } = step;

  switch (action) {
    case "goto":
      console.log(`ðŸŒ Navigating to: ${baseURL}${url}`);
      await page.goto(`${baseURL}${url}`, { 
        waitUntil: 'networkidle',
        timeout: 30000
      });
      k6Sleep(2);
      return true;

    case "click":
      console.log(`ðŸ–±ï¸ Clicking: ${selector}`);
      const clickLocator = page.locator(selector);

      // Auto-scroll until visible
      await autoScrollToElement(page, clickLocator);

      await clickLocator.waitFor({ state: 'visible', timeout: 10000 });
      await clickLocator.click();

      if (waitForLoadState) {
        console.log("â³ Waiting for page to load after click...");
        await page.waitForLoadState('networkidle', { timeout: 30000 });
        k6Sleep(2);
      }
      return true;

    case "type":
      console.log(`âŒ¨ï¸ Typing in: ${selector}`);
      const typeLocator = page.locator(selector);

      await autoScrollToElement(page, typeLocator);

      await typeLocator.waitFor({ state: 'visible', timeout: 10000 });
      await typeLocator.fill(value);
      k6Sleep(1);
      return true;

    case "check":
      console.log(`ðŸ” Checking: ${selector}`);

      const checkLocator = page.locator(selector);

      await autoScrollToElement(page, checkLocator);

      if (waitForLoadState) {
        await page.waitForLoadState('networkidle', { timeout: 30000 });
      }

      await checkLocator.waitFor({ state: 'visible', timeout: 15000 });
      const isVisible = await safeVisible(checkLocator);

      if (!isVisible) {
        throw new Error(`Element not visible - ${selector}`);
      }

      k6Sleep(0.5);
      return true;

    case "scroll":
      console.log(`ðŸ”ƒ Scrolling by: ${value}px`);
      await page.evaluate((y) => window.scrollBy(0, y), parseInt(value));
      k6Sleep(1);
      return true;

    default:
      throw new Error(`Unknown action: ${action}`);
  }
};


export function handleSummary(data) {
  return {
    "summary.html": htmlReport(data),
    "summary.json": JSON.stringify(data),

  };
}
