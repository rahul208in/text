package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/spf13/cobra"
)

// TestCase represents a single test case
type TestCase struct {
	Name     string `json:"name"`
	URL      string `json:"url"`
	Selector string `json:"selector"`
	Text     string `json:"text"`
}

// Config represents the configuration structure
type Config struct {
	BaseURL   string     `json:"baseUrl"`
	TestCases []TestCase `json:"testCases"`
}

const k6Template = `import { browser } from 'k6/browser';
import htmlReport from './bundle.js';
import { check } from 'k6';

const apiErrors = __ENV.apiErrors || "0.01"; // Default to 0.01 if not set
const responseTime = __ENV.responseTime || "300"; // Default to 300ms if not set

export const options = {
    insecureSkipTLSVerify: true,
    thresholds: {
        browser_http_req_failed: [{
            threshold: 'rate<' + apiErrors,
            abortOnFail: false
        }],
        browser_http_req_duration: [{
            threshold: 'avg<' + responseTime,
            abortOnFail: false
        }],
    },
    scenarios: {
        browser_test: {
            executor: 'constant-vus',
            vus: 1,
            duration: "30s",
            options: {
                browser: {
                    type: 'chromium',
                    headless: true,
                }
            }
        }
    }
};

export default async function () {
    const browserInstance = await browser.newPage(); // Create a new browser instance
    const page = browserInstance;
{{range $index, $test := .TestCases}}
    console.log('Navigating to {{$.BaseURL}}{{$test.URL}}');
    await page.goto('{{$.BaseURL}}{{$test.URL}}');
    const pageVisible_{{add $index 1}} = await page.waitForSelector('body', { state: 'visible', timeout: 5000 });
    const pageNavigated_{{add $index 1}} = check(pageVisible_{{add $index 1}}, {
        '{{$test.Name}} navigated successfully to {{$.BaseURL}}{{$test.URL}}': (element) => element !== null
    });

    const navigationScreenshotPath_{{add $index 1}} = 'screenshot_navigation_{{add $index 1}}.png';
    await page.screenshot({ fullPage: true, path: navigationScreenshotPath_{{add $index 1}} });
    console.log('Screenshot saved at: screenshot_navigation_{{add $index 1}}.png');

    if (!pageNavigated_{{add $index 1}}) {
        console.error('Failed to navigate to URL.');
        check(null, { "{{$test.Name}} navigation failed to {{$.BaseURL}}{{$test.URL}}": false });
        return;
    }

    try {
        console.log('Checking for text: "{{$test.Text}}"...');
        const elementText_{{add $index 1}} = await page.locator('{{$test.Selector}}').textContent();
        const textCheck_{{add $index 1}} = check(elementText_{{add $index 1}}, {
            "{{$test.Name}} Text '{{$test.Text}}' is present on the page": (text) => text && text.includes('{{$test.Text}}')
        });

        if (!textCheck_{{add $index 1}}) {
            console.error('Text "{{$test.Text}}" not found on the page.');
            check(null, { '{{$test.Name}} Text "{{$test.Text}}" presence check failed': false });
        }
    } catch (error) {
        console.error('Error while checking for text: "{{$test.Text}}"', error.message);
        check(null, { '{{$test.Name}} Text "{{$test.Text}}" presence check failed': false });
    }

    const screenshotPath_{{add $index 1}} = 'screenshot_{{$test.Name}}_{{add $index 1}}.png';
    await page.screenshot({ fullPage: true, path: screenshotPath_{{add $index 1}} });
    console.log('Screenshot saved at: screenshot_{{$test.Name}}_{{add $index 1}}.png');
    console.log('{{$test.Name}} completed.');
{{end}}
    await page.close();
}

export function handleSummary(data) {
    return {
        'default-summary.html': htmlReport(data),
        'default-summary.json': JSON.stringify(data),
    };
}`

// processEnvironment processes a single environment's browser.json file
func processEnvironment(envName, browserJsonPath, baseDir string) error {
	// Read and parse the browser.json file
	config, err := readConfigFile(browserJsonPath)
	if err != nil {
		return fmt.Errorf("failed to read config: %v", err)
	}

	// Create k6 directory if it doesn't exist
	k6Dir := filepath.Join(baseDir, "k6")
	if err := ensureDirectoryExists(k6Dir); err != nil {
		return fmt.Errorf("failed to create k6 directory: %v", err)
	}

	// Generate output filename
	outputFilename := fmt.Sprintf("vpe-default-browser_%s.js", envName)
	outputPath := filepath.Join(k6Dir, outputFilename)

	// Generate the k6 script
	if err := generateScript(config, outputPath); err != nil {
		return fmt.Errorf("failed to generate k6 script: %v", err)
	}

	// Handle env_vars file
	if err := handleEnvVarsFile(k6Dir); err != nil {
		return fmt.Errorf("failed to handle env_vars file: %v", err)
	}

	fmt.Printf("   üìÑ Generated: %s\n", outputPath)
	return nil
}

// ensureDirectoryExists creates a directory if it doesn't exist
func ensureDirectoryExists(dirPath string) error {
	if _, err := os.Stat(dirPath); os.IsNotExist(err) {
		fmt.Printf("   üìÅ Creating directory: %s\n", dirPath)
		if err := os.MkdirAll(dirPath, 0755); err != nil {
			return fmt.Errorf("failed to create directory '%s': %v", dirPath, err)
		}
		fmt.Printf("   ‚úÖ Directory created successfully\n")
	} else if err != nil {
		return fmt.Errorf("error checking directory '%s': %v", dirPath, err)
	} else {
		fmt.Printf("   üìÅ Directory already exists: %s\n", dirPath)
	}
	return nil
}

// handleEnvVarsFile manages the env_vars file in the k6 directory
func handleEnvVarsFile(k6Dir string) error {
	envVarsPath := filepath.Join(k6Dir, "env_vars")
	
	// Check if env_vars file exists
	if _, err := os.Stat(envVarsPath); os.IsNotExist(err) {
		// Create new env_vars file
		fmt.Printf("   üìù Creating env_vars file: %s\n", envVarsPath)
		content := "export browser=true\n"
		if err := ioutil.WriteFile(envVarsPath, []byte(content), 0644); err != nil {
			return fmt.Errorf("failed to create env_vars file: %v", err)
		}
		fmt.Printf("   ‚úÖ env_vars file created with browser=true\n")
	} else if err != nil {
		return fmt.Errorf("error checking env_vars file: %v", err)
	} else {
		// File exists, check if it contains browser=true
		fmt.Printf("   üìù Checking existing env_vars file\n")
		if err := updateEnvVarsFile(envVarsPath); err != nil {
			return fmt.Errorf("failed to update env_vars file: %v", err)
		}
	}
	
	return nil
}

// updateEnvVarsFile updates the env_vars file to ensure browser=true is set
func updateEnvVarsFile(envVarsPath string) error {
	// Read existing content
	content, err := ioutil.ReadFile(envVarsPath)
	if err != nil {
		return fmt.Errorf("failed to read env_vars file: %v", err)
	}

	lines := strings.Split(string(content), "\n")
	browserExportFound := false
	var updatedLines []string

	// Check each line and update if necessary
	for _, line := range lines {
		trimmedLine := strings.TrimSpace(line)
		if strings.HasPrefix(trimmedLine, "export browser=") {
			browserExportFound = true
			if trimmedLine != "export browser=true" {
				fmt.Printf("   üîÑ Updating browser export from '%s' to 'export browser=true'\n", trimmedLine)
				updatedLines = append(updatedLines, "export browser=true")
			} else {
				fmt.Printf("   ‚úÖ browser=true already set correctly\n")
				updatedLines = append(updatedLines, line)
			}
		} else if trimmedLine != "" {
			updatedLines = append(updatedLines, line)
		}
	}

	// Add browser=true if not found
	if !browserExportFound {
		fmt.Printf("   ‚ûï Adding 'export browser=true' to env_vars file\n")
		updatedLines = append(updatedLines, "export browser=true")
	}

	// Write updated content back to file
	updatedContent := strings.Join(updatedLines, "\n") + "\n"
	if err := ioutil.WriteFile(envVarsPath, []byte(updatedContent), 0644); err != nil {
		return fmt.Errorf("failed to write updated env_vars file: %v", err)
	}

	return nil
}

// readConfigFile reads and parses the JSON configuration file
func readConfigFile(filename string) (*Config, error) {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("error reading config file: %v", err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("error parsing JSON: %v", err)
	}

	return &config, nil
}

// createTemplate creates and returns the k6 script template
func createTemplate() (*template.Template, error) {
	funcMap := template.FuncMap{
		"add": func(a, b int) int {
			return a + b
		},
	}

	tmpl, err := template.New("k6script").Funcs(funcMap).Parse(k6Template)
	if err != nil {
		return nil, fmt.Errorf("error creating template: %v", err)
	}

	return tmpl, nil
}

// generateScript generates the k6 script from the configuration
func generateScript(config *Config, outputPath string) error {
	tmpl, err := createTemplate()
	if err != nil {
		return fmt.Errorf("error creating template: %v", err)
	}

	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("error creating output file: %v", err)
	}
	defer file.Close()

	if err := tmpl.Execute(file, config); err != nil {
		return fmt.Errorf("error executing template: %v", err)
	}

	return nil
}

var (
	pathFlag string
)

func main() {
	rootCmd := &cobra.Command{
		Use:   "vpe",
		Short: "VPE CLI Tool",
	}

	k6Cmd := &cobra.Command{
		Use:   "k6",
		Short: "K6 related commands",
	}

	browserCmd := &cobra.Command{
		Use:   "browser",
		Short: "Generate k6 browser test scripts",
		Long: `Validates browser.json files and generates k6 scripts for each environment.
Environment folders should be located in the specified path.`,
		Example: `  vpe k6 browser -p performance-tests/Config/dev/`,
		Run: func(cmd *cobra.Command, args []string) {
			if pathFlag == "" {
				fmt.Println("Error: please provide a folder path using the -p flag")
				os.Exit(1)
			}

			fmt.Printf("üöÄ K6 Browser Test Generator\n")
			fmt.Printf(strings.Repeat("=", 60) + "\n")
			fmt.Printf("üìÅ Base directory: %s\n", pathFlag)

			// Check if base directory exists
			if _, err := os.Stat(pathFlag); os.IsNotExist(err) {
				fmt.Printf("\n‚ùå Error: base directory '%s' does not exist\n", pathFlag)
				os.Exit(1)
			}

			// Get environment name from path
			envName := filepath.Base(pathFlag)
			browserJsonPath := filepath.Join(pathFlag, "browser.json")

			fmt.Printf("\nüìÅ Processing environment: %s\n", envName)

			// Check if browser.json exists
			if _, err := os.Stat(browserJsonPath); os.IsNotExist(err) {
				fmt.Printf("   ‚ùå Error: browser.json not found in '%s'\n", pathFlag)
				os.Exit(1)
			}

			// Process the single environment
			if err := processEnvironment(envName, browserJsonPath, filepath.Dir(pathFlag)); err != nil {
				fmt.Printf("\n‚ùå Error processing environment: %v\n", err)
				os.Exit(1)
			}

			fmt.Printf("\nüéâ Environment processed successfully!\n")
			fmt.Printf("\nüìã NEXT STEPS:\n")
			fmt.Printf("   ‚Ä¢ Review generated k6 script in '%s/k6/'\n", filepath.Dir(pathFlag))
			fmt.Printf("   ‚Ä¢ Check env_vars file for browser configuration\n")
			fmt.Printf("   ‚Ä¢ Run k6 tests: k6 run %s/k6/vpe-default-browser_%s.js\n", filepath.Dir(pathFlag), envName)
		},
	}

	browserCmd.Flags().StringVarP(&pathFlag, "path", "p", "", "Path to the environment folder (required)")
	browserCmd.MarkFlagRequired("path")

	k6Cmd.AddCommand(browserCmd)
	rootCmd.AddCommand(k6Cmd)

	// Add other commands (like swagger) here
	// k6Cmd.AddCommand(swaggerCmd)

	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
